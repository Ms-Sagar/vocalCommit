from typing import Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)

class DevAgent:
    """Development Agent - Handles code generation and implementation."""
    
    def __init__(self):
        self.name = "Dev Agent"
        self.role = "Software Developer"
    
    async def write_code(self, plan: Dict[str, Any], thought_signature: Optional[str] = None) -> Dict[str, Any]:
        """
        Generate code based on task plan using Gemini AI.
        
        Args:
            plan: Task plan from PM Agent
            thought_signature: Context and insights from previous agent interactions
            
        Returns:
            Dict containing generated code, file structure, and implementation notes
        """
        logger.info(f"Dev Agent generating code with Gemini AI for plan: {plan.get('task_id', 'unknown')}")
        
        try:
            import google.generativeai as genai
            from core.config import settings
            
            # Configure Gemini API
            if not settings.gemini_api_key:
                logger.warning("No Gemini API key found, using fallback code generation")
                return self._fallback_code_generation(plan)
            
            genai.configure(api_key=settings.gemini_api_key)
            model = genai.GenerativeModel('models/gemini-2.5-flash')
            
            # Create detailed prompt for code generation
            prompt = f"""
            As a Senior Software Developer, generate production-ready code for this task:
            
            Task: {plan.get('description', 'Unknown task')}
            Priority: {plan.get('priority', 'medium')}
            Breakdown: {', '.join(plan.get('breakdown', []))}
            Dependencies: {', '.join(plan.get('dependencies', []))}
            
            Please generate:
            1. Complete, functional code files (main implementation + utilities)
            2. Proper error handling and logging
            3. Clear documentation and comments
            4. Appropriate file structure
            5. List of required dependencies
            6. Implementation notes explaining key decisions
            
            Focus on:
            - Clean, maintainable code
            - Best practices and patterns
            - Security considerations
            - Performance optimization
            
            Provide the response with clear file separations and explanations.
            """
            
            response = model.generate_content(prompt)
            
            # Parse the AI response to extract code files
            code_output = self._parse_code_response(response.text, plan)
            
            return {
                "status": "success",
                "agent": self.name,
                "task_id": plan.get("task_id"),
                "code_output": code_output,
                "thought_signature": thought_signature,
                "ai_powered": True
            }
            
        except Exception as e:
            logger.error(f"Error calling Gemini API for code generation: {str(e)}")
            return self._fallback_code_generation(plan, thought_signature)
    
    def _fallback_code_generation(self, plan: Dict[str, Any], thought_signature: Optional[str] = None) -> Dict[str, Any]:
        """Fallback code generation when Gemini API is not available."""
        task_desc = plan.get('description', 'Unknown task')
        
        # Generate more contextual placeholder code
        main_code = f'''"""
{task_desc}
Generated by VocalCommit Dev Agent
"""

def main():
    """Main entry point for {task_desc.lower()}"""
    print("Starting {task_desc.lower()}...")
    
    # TODO: Implement core functionality
    # Based on plan: {', '.join(plan.get('breakdown', [])[:3])}
    
    return "Task completed successfully"

if __name__ == "__main__":
    result = main()
    print(result)
'''
        
        utils_code = f'''"""
Utility functions for {task_desc}
"""

def validate_input(data):
    """Validate input data"""
    if not data:
        raise ValueError("Input data cannot be empty")
    return True

def format_response(data):
    """Format response data"""
    return {{
        "status": "success",
        "data": data,
        "timestamp": "2024-01-23T00:00:00Z"
    }}

def handle_error(error):
    """Handle and log errors"""
    print(f"Error occurred: {{error}}")
    return {{"status": "error", "message": str(error)}}
'''
        
        code_output = {
            "files": {
                "main.py": main_code,
                "utils.py": utils_code
            },
            "structure": {
                "directories": ["src", "tests", "docs"],
                "entry_point": "main.py"
            },
            "dependencies": self._infer_dependencies(task_desc),
            "implementation_notes": [
                f"Generated code structure for: {task_desc}",
                "Added basic error handling and validation",
                "Included utility functions for common operations",
                "Ready for further development and testing"
            ]
        }
        
        return {
            "status": "success",
            "agent": self.name,
            "task_id": plan.get("task_id"),
            "code_output": code_output,
            "thought_signature": thought_signature,
            "ai_powered": False
        }
    
    def _parse_code_response(self, response_text: str, plan: Dict[str, Any]) -> Dict[str, Any]:
        """Parse Gemini AI response to extract code files and metadata."""
        import re
        
        files = {}
        dependencies = []
        implementation_notes = []
        
        # Try to extract code blocks
        code_blocks = re.findall(r'```(?:python|py)?\n(.*?)\n```', response_text, re.DOTALL)
        
        if code_blocks:
            # If we have code blocks, try to identify files
            for i, code in enumerate(code_blocks):
                if i == 0:
                    files["main.py"] = code.strip()
                elif i == 1:
                    files["utils.py"] = code.strip()
                else:
                    files[f"module_{i}.py"] = code.strip()
        else:
            # Fallback: use the entire response as main.py
            files["main.py"] = f'"""\n{plan.get("description", "Generated code")}\n"""\n\n' + response_text[:1000]
        
        # Extract dependencies mentioned in the response
        dep_patterns = [
            r'import\s+(\w+)',
            r'from\s+(\w+)',
            r'pip\s+install\s+(\w+)',
            r'requirements?.*?(\w+)'
        ]
        
        for pattern in dep_patterns:
            matches = re.findall(pattern, response_text, re.IGNORECASE)
            dependencies.extend(matches)
        
        # Add inferred dependencies based on task
        dependencies.extend(self._infer_dependencies(plan.get('description', '')))
        
        # Remove duplicates and common built-ins
        builtin_modules = {'os', 'sys', 'json', 'time', 'datetime', 're', 'math', 'random'}
        dependencies = list(set(dep for dep in dependencies if dep not in builtin_modules))
        
        # Extract implementation notes
        note_patterns = [
            r'(?:Note|Important|Key|Feature):\s*(.+)',
            r'(?:Implementation|Design)\s+(?:note|decision):\s*(.+)',
        ]
        
        for pattern in note_patterns:
            matches = re.findall(pattern, response_text, re.IGNORECASE)
            implementation_notes.extend(matches)
        
        if not implementation_notes:
            implementation_notes = [
                "AI-generated code with best practices",
                "Includes error handling and documentation",
                "Ready for testing and deployment"
            ]
        
        return {
            "files": files,
            "structure": {
                "directories": ["src", "tests", "docs"],
                "entry_point": "main.py"
            },
            "dependencies": dependencies[:10],  # Limit to 10 dependencies
            "implementation_notes": implementation_notes[:5]  # Limit to 5 notes
        }
    
    def _infer_dependencies(self, description: str) -> list:
        """Infer likely dependencies based on task description."""
        deps = []
        desc_lower = description.lower()
        
        # Web frameworks
        if any(word in desc_lower for word in ['api', 'web', 'server', 'endpoint']):
            deps.extend(['fastapi', 'uvicorn'])
        
        # Database
        if any(word in desc_lower for word in ['database', 'db', 'data', 'store']):
            deps.extend(['sqlalchemy', 'psycopg2'])
        
        # Frontend
        if any(word in desc_lower for word in ['react', 'frontend', 'ui', 'interface']):
            deps.extend(['react', 'typescript'])
        
        # Data processing
        if any(word in desc_lower for word in ['data', 'analysis', 'process']):
            deps.extend(['pandas', 'numpy'])
        
        # Testing
        deps.extend(['pytest', 'requests'])
        
        return deps
    
    async def edit_ui_files(self, plan: Dict[str, Any], thought_signature: Optional[str] = None) -> Dict[str, Any]:
        """
        Edit existing UI files based on task plan using Gemini AI.
        
        Args:
            plan: Task plan from PM Agent for UI editing
            thought_signature: Context and insights from previous agent interactions
            
        Returns:
            Dict containing modified files and UI changes made
        """
        logger.info(f"Dev Agent editing UI files with Gemini AI for plan: {plan.get('task_id', 'unknown')}")
        
        try:
            import google.generativeai as genai
            from core.config import settings
            import os
            
            # Configure Gemini API
            if not settings.gemini_api_key:
                logger.warning("No Gemini API key found, using fallback UI editing")
                return self._fallback_ui_editing(plan)
            
            genai.configure(api_key=settings.gemini_api_key)
            model = genai.GenerativeModel('models/gemini-2.5-flash')
            
            # Read current UI files
            current_files = {}
            target_files = plan.get("target_files", ["src/App.tsx"])
            
            # Get the orchestrator directory (where this script is running from)
            orchestrator_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
            # todo-ui is now inside orchestrator
            todo_ui_base = os.path.join(orchestrator_dir, "todo-ui")
            
            for file_path in target_files:
                full_path = os.path.join(todo_ui_base, file_path)
                if os.path.exists(full_path):
                    with open(full_path, 'r', encoding='utf-8') as f:
                        current_files[file_path] = f.read()
                else:
                    logger.error(f"Target file not found: {full_path}")
            
            if not current_files:
                return {
                    "status": "error",
                    "message": "No target files found for UI editing"
                }
            
            # Create detailed prompt for UI editing
            prompt = f"""
            As a Senior React Developer, modify the existing Todo UI based on this request:
            
            Task: {plan.get('description', 'Unknown task')}
            Priority: {plan.get('priority', 'medium')}
            Breakdown: {', '.join(plan.get('breakdown', []))}
            
            Current Files:
            {self._format_files_for_prompt(current_files)}
            
            Please:
            1. Analyze the current React code structure
            2. Implement the requested changes while maintaining existing functionality
            3. Follow React best practices and TypeScript conventions
            4. Ensure accessibility and responsive design
            5. Maintain the existing API integration patterns
            6. Keep the current styling approach consistent
            
            Provide the complete modified file content for each file that needs changes.
            Explain what changes were made and why.
            
            Focus on:
            - Clean, maintainable React code
            - Proper TypeScript typing
            - Accessibility (ARIA labels, keyboard navigation)
            - Responsive design
            - User experience improvements
            """
            
            response = model.generate_content(prompt)
            
            # Parse the AI response and apply changes
            ui_changes = self._parse_ui_response(response.text, current_files, plan)
            
            # Write modified files back to disk using the new file operations
            from tools.file_ops import update_todo_ui_component
            
            modified_files = []
            component_updates = {}
            
            for file_path, new_content in ui_changes.get("modified_files", {}).items():
                component_updates[file_path] = new_content
            
            if component_updates:
                update_result = update_todo_ui_component(component_updates)
                
                if update_result["status"] in ["success", "partial_success"]:
                    modified_files = [f["file_path"] for f in update_result["updated_files"]]
                    logger.info(f"Successfully updated {len(modified_files)} UI files")
                else:
                    return {
                        "status": "error",
                        "message": f"Failed to update UI files: {update_result.get('error', 'Unknown error')}"
                    }
            
            return {
                "status": "success",
                "agent": self.name,
                "task_id": plan.get("task_id"),
                "modified_files": modified_files,
                "ui_changes": ui_changes.get("changes_made", []),
                "thought_signature": thought_signature,
                "ai_powered": True
            }
            
        except Exception as e:
            logger.error(f"Error calling Gemini API for UI editing: {str(e)}")
            return self._fallback_ui_editing(plan, thought_signature)
    
    def _format_files_for_prompt(self, files: Dict[str, str]) -> str:
        """Format files for inclusion in Gemini prompt."""
        formatted = ""
        for file_path, content in files.items():
            formatted += f"\n--- {file_path} ---\n{content}\n"
        return formatted
    
    def _parse_ui_response(self, response_text: str, current_files: Dict[str, str], plan: Dict[str, Any]) -> Dict[str, Any]:
        """Parse Gemini AI response to extract modified files and changes."""
        import re
        
        modified_files = {}
        changes_made = []
        
        # Try to extract code blocks for each file
        for file_path in current_files.keys():
            # Look for file-specific code blocks
            file_pattern = rf"(?:```(?:typescript|tsx|react)?\n)?(.*?)(?:\n```)"
            matches = re.findall(file_pattern, response_text, re.DOTALL)
            
            if matches:
                # Use the largest code block as the modified file
                largest_match = max(matches, key=len)
                if len(largest_match.strip()) > 100:  # Ensure it's substantial content
                    modified_files[file_path] = largest_match.strip()
            
            # If no good code block found, try to extract changes and apply them
            if file_path not in modified_files:
                # Fallback: make minimal changes based on the request
                modified_files[file_path] = self._apply_minimal_changes(
                    current_files[file_path], 
                    plan.get('description', ''), 
                    response_text
                )
        
        # Extract change descriptions
        change_patterns = [
            r'(?:Added|Modified|Updated|Changed|Implemented):\s*(.+)',
            r'(?:Change|Modification|Update)\s*\d*:\s*(.+)',
        ]
        
        for pattern in change_patterns:
            matches = re.findall(pattern, response_text, re.IGNORECASE)
            changes_made.extend(matches)
        
        if not changes_made:
            changes_made = [
                f"Applied UI modifications based on request: {plan.get('description', 'Unknown')}",
                "Updated React components with new functionality",
                "Maintained existing styling and API integration"
            ]
        
        return {
            "modified_files": modified_files,
            "changes_made": changes_made[:5]  # Limit to 5 changes
        }
    
    def _apply_minimal_changes(self, original_content: str, description: str, ai_response: str) -> str:
        """Apply minimal changes when full code extraction fails."""
        # This is a fallback - in practice, you'd implement more sophisticated parsing
        # For now, we'll add a comment indicating the change was requested
        
        lines = original_content.split('\n')
        
        # Add a comment near the top indicating the change
        comment = f"  // AI Modification: {description}"
        
        # Find a good place to insert the comment (after imports, before main component)
        insert_index = 0
        for i, line in enumerate(lines):
            if line.strip().startswith('function App()') or line.strip().startswith('const App'):
                insert_index = i
                break
        
        lines.insert(insert_index, comment)
        return '\n'.join(lines)
    
    def _fallback_ui_editing(self, plan: Dict[str, Any], thought_signature: Optional[str] = None) -> Dict[str, Any]:
        """Fallback UI editing when Gemini API is not available."""
        from tools.file_ops import read_from_todo_ui, update_todo_ui_component
        
        # Read current files and make minimal changes
        target_files = plan.get("target_files", ["src/App.tsx"])
        component_updates = {}
        
        for file_path in target_files:
            read_result = read_from_todo_ui(file_path)
            
            if read_result["status"] == "success":
                content = read_result["content"]
                
                # Add a comment indicating the change was requested
                modified_content = content.replace(
                    'function App() {',
                    f'function App() {{\n  // AI Modification requested: {plan.get("description", "Unknown")}'
                )
                
                component_updates[file_path] = modified_content
            else:
                logger.error(f"Error reading file {file_path}: {read_result.get('error', 'Unknown error')}")
        
        if component_updates:
            update_result = update_todo_ui_component(component_updates)
            
            if update_result["status"] in ["success", "partial_success"]:
                modified_files = [f["file_path"] for f in update_result["updated_files"]]
                
                return {
                    "status": "success",
                    "agent": self.name,
                    "task_id": plan.get("task_id"),
                    "modified_files": modified_files,
                    "ui_changes": [
                        f"Added comment indicating requested change: {plan.get('description', 'Unknown')}",
                        "Fallback modification applied (Gemini API not available)"
                    ],
                    "thought_signature": thought_signature,
                    "ai_powered": False
                }
            else:
                return {
                    "status": "error",
                    "message": f"Failed to update UI files: {update_result.get('error', 'Unknown error')}"
                }
        else:
            return {
                "status": "error",
                "message": "No files could be read for modification"
            }
